# Algorithm Shortest Path(G,s)
# Input: A weighted graph G and a source vertex s 
# คือ weigbted graph ที่มีน้ำหนักของ edge เป็นบวก
# Output: A shortest path tree rooted at s'

# ค่าเริ่มต้น ให้ D[s] = 0 D[v] = infinity สำหรับทุก v ที่ไม่ใช่ s

#  สร้าง Q เป็น priority queue ที่เก็บ vertex ที่ยังไม่ถูกเยี่ยมชม
# protity Queue คืออะไร
#  คือ คิวที่มีการจัดลำดับความสำคัญของข้อมูลในคิว โดยจะมีการเปรียบเทียบค่าของข้อมูลในคิว
# จัดลำกับตามเส้นทาง

# ถ้า Q ไม่ใช่ empyty
#  ทำให้  u = ค่าที่ส่งกลับจาก pop ของ Q
#  สำหรับทุก v ที่อยู่ใน adj[u] do
#      ถ้า D[u] + w(u,v) < D[v] do
#          D[v] = D[u] + w(u,v)
# เปลียนแปลง D[v] เป็น key ของ Q
# ส่งค่า D[v]  ของ vertex v นั้นๆ

# 1. เริ่มต้นจาก node ไหรได้แต่ต้องตามโจทย์
# 2. ดูว่า node ที่เราอยู่มี node อะไรบ้างที่เชื่อมต่อกับ node นนี้ ไปไหนได้บ้าง ด้วยระยะทางเท่าไหร่ (min ของระยะทางทั้งหมดที่ไปได้)
# min( (ระยะทางที่สั้นสุด), infinity , (ระยะทางที่ไปได้) )
# 2.1 ถ้า min( (ระยะทางที่สั้นสุด), infinity , (ระยะทางที่ไปได้) ) = infinity แสดงว่า node นี้ไม่สามารถไปไหนได้เลย
# 2.2 ถ้า min( (ระยะทางที่สั้นสุด), infinity , (ระยะทางที่ไปได้) ) = (ระยะทางที่ไปได้) แสดงว่า node นี้สามารถไปได้ด้วยระยะทางที่น้อยที่สุด

# 3. ใส่ตัวเลือกที่สั้นที่สุดเข้าไปใน Priority Queue 
# A | none
# B | 184
# C | 200

# F | infinity
# G | infinity
# infity คือ ยังไม่เคยไปถึง node นี้เลย
#**  ตอนเปรียบเทียบถ้าวนมาทางเดิมแล้วค่าเก่าเทียบกลับค่าใหม่แล้วค่าเก่ามันน้อยกว่าให้ใช้ค่าเก่า
#**  ถ้าไป node ใหม่แล้วค่าเก่ามันน้อยกว่าให้ใช้ค่าเก่า

# ถ้าคำถามถามทางที่ไไม่ได้มาจากจุดเริ่มต้น ก็ให้ใช้ค่า infinity หรือ หาค่าไม่ได้


# Minimun Spanning Tree (MST) คืออะไร
# หาเส้นทางที่เชื่อมต่อกันทั้งหมดในกราฟ โดยที่น้ำหนักของเส้นทางรวมกันน้อยที่สุด
# โดยที่ไม่ต้องมีวงกลมในกราฟ